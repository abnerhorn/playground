/**
 * Launch Wizard API
 * =================
 * 
 * Generates project files from the launch wizard input.
 * 
 * POST /api/launch
 * - Validates input data
 * - Generates APP_ID for deployment detection
 * - Creates personalized project files
 * - Returns Cursor prompt for building
 * 
 * Development only — returns 403 in production.
 */

import { NextResponse } from 'next/server'
import { promises as fs } from 'fs'
import path from 'path'
import { randomUUID } from 'crypto'
import {
  type LaunchData,
  generateBuildMd,
  generateReadme,
  generateSiteConfig,
  generateCursorPrompt,
  generateTomorrowMd,
  generateFutureMd,
} from './templates'

// -----------------------------------------------------------------------------
// Constants
// -----------------------------------------------------------------------------

const PROJECT_ROOT = process.cwd()
const ENV_LOCAL_PATH = '.env.local'
const APP_ID_KEY = 'APP_ID'
const MIN_DESCRIPTION_LENGTH = 20

/** Files generated by the wizard, mapped to their generator functions */
const GENERATED_FILES: ReadonlyArray<[string, (data: LaunchData) => string]> = [
  ['plans/BUILD.md', generateBuildMd],
  ['lib/site-config.ts', generateSiteConfig],
  ['README.md', generateReadme],
  ['plans/Tomorrow.md', generateTomorrowMd],
  ['plans/Future.md', generateFutureMd],
]

// -----------------------------------------------------------------------------
// Types
// -----------------------------------------------------------------------------

type SuccessResponse = {
  success: true
  filesModified: string[]
  cursorPrompt: string
}

type ErrorResponse = {
  success: false
  error: string
}

type ApiResponse = SuccessResponse | ErrorResponse

// -----------------------------------------------------------------------------
// Response Helpers
// -----------------------------------------------------------------------------

function success(data: Omit<SuccessResponse, 'success'>): NextResponse<ApiResponse> {
  return NextResponse.json({ success: true, ...data })
}

function error(message: string, status: number): NextResponse<ApiResponse> {
  return NextResponse.json({ success: false, error: message }, { status })
}

const forbidden = (msg = 'Development only') => error(msg, 403)
const badRequest = (msg: string) => error(msg, 400)
const serverError = (msg: string) => error(msg, 500)

// -----------------------------------------------------------------------------
// Validation
// -----------------------------------------------------------------------------

function isValidLaunchData(data: unknown): data is LaunchData {
  if (!data || typeof data !== 'object') return false
  
  const d = data as Record<string, unknown>
  
  const hasValidProjectName = 
    typeof d.projectName === 'string' && 
    d.projectName.trim().length > 0
    
  const hasValidTagline = 
    typeof d.tagline === 'string' && 
    d.tagline.trim().length > 0
    
  const hasValidDescription = 
    typeof d.appDescription === 'string' && 
    d.appDescription.trim().length >= MIN_DESCRIPTION_LENGTH

  return hasValidProjectName && hasValidTagline && hasValidDescription
}

// -----------------------------------------------------------------------------
// File Operations
// -----------------------------------------------------------------------------

async function writeProjectFile(relativePath: string, content: string): Promise<void> {
  const fullPath = path.join(PROJECT_ROOT, relativePath)
  await fs.mkdir(path.dirname(fullPath), { recursive: true })
  await fs.writeFile(fullPath, content, 'utf-8')
}

async function ensureAppId(): Promise<{ appId: string; isNew: boolean }> {
  const envPath = path.join(PROJECT_ROOT, ENV_LOCAL_PATH)
  
  // Check if APP_ID already exists
  try {
    const existing = await fs.readFile(envPath, 'utf-8')
    const match = existing.match(/^APP_ID=(.+)$/m)
    
    if (match?.[1]) {
      return { appId: match[1], isNew: false }
    }
    
    // File exists but no APP_ID — append it
    const appId = randomUUID()
    await fs.appendFile(envPath, `\n# App identifier for deployment detection\n${APP_ID_KEY}=${appId}\n`)
    return { appId, isNew: true }
    
  } catch (err) {
    // File doesn't exist — create it
    if ((err as NodeJS.ErrnoException).code === 'ENOENT') {
      const appId = randomUUID()
      await fs.writeFile(
        envPath, 
        `# App identifier for deployment detection\n${APP_ID_KEY}=${appId}\n`,
        'utf-8'
      )
      return { appId, isNew: true }
    }
    throw err
  }
}

// -----------------------------------------------------------------------------
// Route Handler
// -----------------------------------------------------------------------------

export async function POST(request: Request): Promise<NextResponse<ApiResponse>> {
  // Guard: Development only
  if (process.env.NODE_ENV !== 'development') {
    return forbidden()
  }

  // Parse request body
  let data: unknown
  try {
    data = await request.json()
  } catch {
    return badRequest('Invalid JSON in request body')
  }

  // Validate input
  if (!isValidLaunchData(data)) {
    return badRequest(
      `Missing or invalid fields. Required: projectName, tagline, appDescription (min ${MIN_DESCRIPTION_LENGTH} chars)`
    )
  }

  try {
    const filesModified: string[] = []

    // Ensure APP_ID exists for deployment detection
    const { isNew } = await ensureAppId()
    if (isNew) {
      filesModified.push(`${ENV_LOCAL_PATH} (APP_ID)`)
    }

    // Generate project files
    for (const [filePath, generator] of GENERATED_FILES) {
      await writeProjectFile(filePath, generator(data))
      filesModified.push(filePath)
    }

    return success({
      filesModified,
      cursorPrompt: generateCursorPrompt(data),
    })

  } catch (err) {
    const message = err instanceof Error ? err.message : 'Unknown error'
    console.error('[launch] Generation failed:', message)
    return serverError(`Failed to generate project files: ${message}`)
  }
}
